# DSP Architecture: Spyder2000

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-3 implementation. Stage 1 (Foundation+Shell) cannot proceed without this file. Stage 2 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (research-planning-agent)
**Generated:** 2025-11-17
**Referenced by:** Stage 1 (Foundation+Shell), Stage 2 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Adaptive Pre-Clipping Filter System

#### Treble Shelf Filter
- **JUCE Class:** `juce::dsp::IIR::Filter<float>` with `juce::dsp::IIR::Coefficients<float>::makeHighShelf()`
- **Purpose:** Boosts high frequencies at low gain settings (boost mode for dirty amps)
- **Parameters Affected:** gain
- **Configuration:**
  - Frequency: 2000 Hz (upper midrange/presence region)
  - Q: 0.707 (standard shelf slope)
  - Gain: +6dB maximum boost (at gain = 0)
  - Smooth transition to 0dB at mid-range gain settings

#### Midrange Peak Filter
- **JUCE Class:** `juce::dsp::IIR::Filter<float>` with `juce::dsp::IIR::Coefficients<float>::makePeakFilter()`
- **Purpose:** Emphasizes midrange at high gain settings (distortion mode for clean amps)
- **Parameters Affected:** gain
- **Configuration:**
  - Center frequency: 800 Hz (guitar fundamental region)
  - Q: 1.5 (focused peak, not too narrow)
  - Gain: +9dB maximum boost (at gain = 10)
  - Smooth transition from 0dB at low gain settings

#### Crossfading Logic
- **JUCE Class:** Custom implementation (simple gain calculations)
- **Purpose:** Blends treble shelf and midrange peak based on gain parameter
- **Parameters Affected:** gain
- **Configuration:**
  - Low gain (0-4): Emphasize treble shelf (shelf gain = full, peak gain = 0)
  - Mid gain (4-6): Transition region (both filters active, crossfading)
  - High gain (6-10): Emphasize midrange peak (peak gain = full, shelf gain = 0)
  - Crossfading curve: Exponential (smooth transition, no abrupt changes)
  - Formula: `shelfGain = exp(-gainValue * 0.8)`, `peakGain = 1.0 - exp(-(gainValue - 4.0) * 0.8)`

### Nonlinear Distortion Stage

#### Waveshaper
- **JUCE Class:** `juce::dsp::WaveShaper<float>` with custom Line 6 transfer function
- **Purpose:** Apply authentic Line 6 patent nonlinear transfer function for harmonic distortion
- **Parameters Affected:** gain
- **Configuration:**
  - **Primary approach:** Line 6 Patent U.S. Patent 5,789,689 (Figure 14) waveshaping
    - **Transfer function (piecewise):**
      ```cpp
      float waveshapeLine6(float input) {
          // Line 6 patent U.S. Patent 5,789,689 figure 14
          if (input >= -1.0f && input <= 1.0f) {
              if (input < -0.08905f)
                  return (-3.f/4.0f) * (1.0f - pow(1.0f - (abs(input) - 0.032847f), 12.0f)
                         + (1.0f/3.0f) * (abs(input) - 0.032847f)) + 0.01f;
              else if (input < 0.320018f)
                  return -6.153f * pow(input, 2.0f) + 3.9375f * input;
              else
                  return 0.630035f;
          }
          return juce::jlimit(-1.0f, 1.0f, input);
      }
      ```
    - **Piecewise regions:**
      1. **Region 1** (input < -0.08905): Sharp asymmetric clipping with 12th-power polynomial
      2. **Region 2** (-0.08905 to 0.320018): Quadratic soft saturation
      3. **Region 3** (input >= 0.320018): Hard clip at 0.630035
    - **Characteristics:**
      - Asymmetric saturation (different behavior for positive/negative)
      - Sharp transition in negative region (12th power creates edge)
      - Smooth quadratic in mid-region (musical saturation)
      - Hard clip at high levels (prevents excessive output)
    - **Drive gain mapping:** gain parameter (0-10) → 3dB to 40dB → linear gain 1.41 to 100.0
    - **Formula:** `driveGain = pow(10.0, (3.0 + (gainValue * 3.7)) / 20.0)`
    - **Application:** `output = waveshapeLine6(driveGain * input)`
  - **Alternative (fallback):** Hyperbolic tangent (tanh) if Line 6 formula proves too CPU-intensive
    - Transfer function: `output = tanh(driveGain * input)`
    - Symmetric soft clipping, simpler computation
  - **Note:** Authentic Line 6 patent formula from U.S. Patent 5,789,689 provides exact POD/Spider character

#### Oversampling System
- **JUCE Class:** `juce::dsp::Oversampling<float>`
- **Purpose:** Reduce aliasing artifacts from nonlinear processing
- **Parameters Affected:** None (quality mode could be user preference)
- **Configuration:**
  - **Default quality:** 8x oversampling (recommended for heavy distortion per research)
  - Filter type: Polyphase IIR (efficient, near-linear phase)
  - Cascade stages: 3 stages (8x → 4x → 2x → 1x via halfband filters)
  - Latency: Automatically compensated by JUCE Oversampling class
  - **Quality modes (future enhancement):**
    - 2x: Low quality (not recommended for high gain)
    - 4x: Medium quality (acceptable for moderate gain)
    - 8x: High quality (default, recommended)
    - Adaptive: Switches between 4x/8x based on gain setting (future optimization)

### Tilt Filter (Tone Control)

- **JUCE Class:** Two `juce::dsp::IIR::Filter<float>` instances (low shelf + high shelf)
- **Purpose:** Simultaneous boost/cut of highs and lows around 680Hz pivot frequency
- **Parameters Affected:** tone
- **Configuration:**
  - **Low shelf:**
    - Frequency: 680 Hz
    - Q: 0.707
    - Gain: -12dB to +12dB (inverse of tone parameter)
    - Formula: `lowShelfGain_dB = (5.0 - toneValue) * 2.4` (maps tone 0→10 to +12dB→-12dB)
  - **High shelf:**
    - Frequency: 680 Hz
    - Q: 0.707
    - Gain: -12dB to +12dB (proportional to tone parameter)
    - Formula: `highShelfGain_dB = (toneValue - 5.0) * 2.4` (maps tone 0→10 to -12dB→+12dB)
  - **Result:**
    - tone = 0: +12dB lows, -12dB highs (darkest)
    - tone = 5: 0dB both (flat response)
    - tone = 10: -12dB lows, +12dB highs (brightest)

### DC Blocking Filter

- **JUCE Class:** `juce::dsp::IIR::Filter<float>` with `juce::dsp::IIR::Coefficients<float>::makeHighPass()`
- **Purpose:** Remove DC offset introduced by waveshaping
- **Parameters Affected:** None (always active)
- **Configuration:**
  - Cutoff frequency: 20 Hz
  - Q: 0.707 (standard Butterworth response)
  - Order: First-order (minimal phase shift, sufficient for DC removal)
  - Always active (prevents DC buildup in feedback systems, protects speakers)

### Output Level Control

- **JUCE Class:** Custom implementation (simple gain multiplication)
- **Purpose:** Makeup gain after clipping stage
- **Parameters Affected:** level
- **Configuration:**
  - Range: -∞ to 0dB (mute to unity gain)
  - Mapping: level parameter (0-10) → -60dB to 0dB → linear gain 0.001 to 1.0
  - Formula: `outputGain = (levelValue < 0.01) ? 0.0 : pow(10.0, (levelValue - 10.0) * 6.0 / 20.0)`
  - Smooth ramping: Use parameter smoothing to avoid clicks (5ms ramp typical)
  - Assumes nonlinear section clips at ±1 (output level provides makeup only, no boost above unity)

---

## Processing Chain

```
Input (Stereo)
  ↓
Adaptive Pre-Clipping Filter (Parallel Topology)
  ├─ Treble Shelf Filter (emphasized at low gain) ← gain parameter
  └─ Midrange Peak Filter (emphasized at high gain) ← gain parameter
  ↓ [Crossfaded mix based on gain]
  ↓
Oversampling Upsample (8x)
  ↓
Nonlinear Waveshaper (Line 6 Patent 5,789,689) ← gain parameter (drive amount)
  ↓
Oversampling Downsample (8x → 1x with anti-aliasing)
  ↓
Tilt Filter (Two shelves @ 680Hz) ← tone parameter
  ↓
DC Blocking Filter (20Hz highpass, always active)
  ↓
Output Level Control (makeup gain) ← level parameter
  ↓
Output (Stereo)
```

**Routing notes:**
- Pre-clipping filter uses parallel topology: both filters process input, then outputs are mixed based on crossfading gain
- Oversampling ONLY wraps the waveshaper (most expensive operation, filters are sample-rate independent)
- DC blocking happens after all nonlinear processing to remove any accumulated DC offset
- All processing is stereo (dual-mono, independent left/right channels)
- No feedback loops or sidechain inputs

---

## System Architecture

**No additional system features required:**
- No file I/O (pure DSP effect)
- No multi-output routing (stereo in, stereo out)
- No MIDI handling (audio effect, not instrument)
- State persistence handled automatically by APVTS (parameters only)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| gain | Float | 0-10 | Pre-Clipping Filter + Waveshaper | Maps to 3-40dB drive. Controls filter crossfading (0-4 = treble shelf, 6-10 = midrange peak) AND waveshaper drive amount |
| tone | Float | 0-10 | Tilt Filter | Maps to ±12dB tilt @ 680Hz. 0 = +12dB lows/-12dB highs, 5 = flat, 10 = -12dB lows/+12dB highs |
| level | Float | 0-10 | Output Level Control | Maps to -∞ to 0dB output gain. 0 = mute, 10 = unity (0dB) |

**Parameter interaction notes:**
- **gain** affects TWO components: pre-clipping filter emphasis AND waveshaper drive amount
  - Low gain (0-4): Treble shelf boost + moderate waveshaper drive (boost mode)
  - High gain (6-10): Midrange peak boost + heavy waveshaper drive (distortion mode)
- **tone** is independent (post-distortion tone shaping)
- **level** is independent (final output makeup gain)

---

## Algorithm Details

### Adaptive Pre-Clipping Filter Crossfading

**Algorithm:** Exponential crossfade between treble shelf and midrange peak filters

**Implementation notes:**
- Both filters process input in parallel (not series)
- Crossfading gains calculated per-parameter update (not per-sample)
- Smooth exponential curves prevent abrupt tonal changes
- Formulas:
  - `shelfWeight = exp(-gainValue * 0.8)` (full at gain=0, near-zero at gain=10)
  - `peakWeight = 1.0 - exp(-(gainValue - 4.0) * 0.8)` (near-zero at gain=0, full at gain=10)
  - `output = (shelfOutput * shelfWeight) + (peakOutput * peakWeight)`
- Edge case: At gain=5 (midpoint), both filters contribute equally (~50% each)

### Nonlinear Waveshaping Transfer Function

**Algorithm:** Line 6 Patent U.S. Patent 5,789,689 (Figure 14) piecewise waveshaping

**Implementation notes:**
- **Transfer function:** Piecewise function with three regions:
  ```cpp
  float waveshapeLine6(float input) {
      if (input >= -1.0f && input <= 1.0f) {
          if (input < -0.08905f)  // Region 1: Sharp asymmetric clipping
              return (-3.f/4.0f) * (1.0f - pow(1.0f - (abs(input) - 0.032847f), 12.0f)
                     + (1.0f/3.0f) * (abs(input) - 0.032847f)) + 0.01f;
          else if (input < 0.320018f)  // Region 2: Quadratic soft saturation
              return -6.153f * pow(input, 2.0f) + 3.9375f * input;
          else  // Region 3: Hard clip
              return 0.630035f;
      }
      return juce::jlimit(-1.0f, 1.0f, input);  // Safety clamp
  }
  ```
- **Drive gain calculation:**
  - gain parameter (0-10) → dB range (3-40dB)
  - Formula: `dB = 3.0 + (gainValue * 3.7)`
  - Convert to linear: `driveGain = pow(10.0, dB / 20.0)`
  - Example: gain=0 → 3dB → 1.41x, gain=5 → 21.5dB → 11.9x, gain=10 → 40dB → 100x
- **Application:** `output = waveshapeLine6(driveGain * input)`
- **Characteristics:**
  - **Asymmetric:** Different behavior for positive vs negative inputs (creates even harmonics)
  - **Region 1:** 12th-power polynomial creates sharp edge for aggressive clipping on negative side
  - **Region 2:** Smooth quadratic provides musical saturation in mid-range
  - **Region 3:** Hard clip at 0.630035 prevents excessive output
- **CPU considerations:** More expensive than tanh due to pow() calls and branching, but authentic Line 6 character
- Applied per-sample within oversampled domain (8x sample rate for alias reduction)
- **Fallback (if CPU critical):** Tanh waveshaping `output = tanh(driveGain * input)` provides similar character with lower CPU cost

### Oversampling Implementation

**Algorithm:** Cascade of halfband polyphase IIR filters

**Implementation notes:**
- JUCE Oversampling class handles upsampling, downsampling, and anti-aliasing automatically
- Configuration:
  ```cpp
  juce::dsp::Oversampling<float> oversampler;
  oversampler.initProcessing(maximumBlockSize);
  oversampler.reset();
  ```
- Processing pattern:
  ```cpp
  auto oversampledBlock = oversampler.processSamplesUp(inputBlock);
  applyWaveshaping(oversampledBlock); // Process at 8x rate
  oversampler.processSamplesDown(outputBlock);
  ```
- Latency compensation: Use `oversampler.getLatencyInSamples()` and report via `AudioProcessor::setLatencySamples()`
- Quality vs CPU: 8x oversampling uses ~4x CPU vs no oversampling (acceptable for high-quality guitar distortion)

### Tilt Filter Implementation

**Algorithm:** Two biquad shelving filters with opposite gains

**Implementation notes:**
- Low shelf coefficients:
  ```cpp
  auto lowShelfGain_dB = (5.0f - toneValue) * 2.4f;
  auto lowShelfCoeffs = juce::dsp::IIR::Coefficients<float>::makeLowShelf(
      sampleRate, 680.0f, 0.707f, juce::Decibels::decibelsToGain(lowShelfGain_dB));
  ```
- High shelf coefficients:
  ```cpp
  auto highShelfGain_dB = (toneValue - 5.0f) * 2.4f;
  auto highShelfCoeffs = juce::dsp::IIR::Coefficients<float>::makeHighShelf(
      sampleRate, 680.0f, 0.707f, juce::Decibels::decibelsToGain(highShelfGain_dB));
  ```
- Series configuration: Low shelf → High shelf (order doesn't affect frequency response, both are shelves)
- Pivot frequency (680Hz) verified as reasonable for guitar (vocal/fundamental range)
- Phase response: Shelving filters introduce minimal phase shift at 680Hz (pivot point remains phase-coherent)

---

## Integration Points

### Feature Dependencies

- **Pre-clipping filter → Waveshaper:** Pre-filter shapes frequency content before distortion (order critical)
- **Waveshaper → Oversampling:** Oversampling must wrap waveshaper to reduce aliasing (architectural requirement)
- **Waveshaper → DC blocking:** DC blocking must follow waveshaper to remove offset introduced by asymmetric clipping
- **All DSP → Output level:** Output level is final stage (applies makeup gain to processed signal)

### Parameter Interactions

- **gain parameter dual-purpose:**
  - Controls pre-clipping filter crossfading (treble shelf ↔ midrange peak)
  - Controls waveshaper drive amount (3dB ↔ 40dB)
  - Both effects scale together (intentional design for cohesive gain staging)

- **tone parameter independence:**
  - Operates post-distortion (doesn't affect waveshaper input)
  - No interaction with gain parameter (separate tonal control)

- **level parameter independence:**
  - Final makeup gain only
  - No interaction with gain or tone (pure output scaling)

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Adaptive pre-clipping filter:** Shape frequency content before nonlinearity
   - WHY FIRST: Pre-emphasis affects harmonic generation in waveshaper
   - WRONG ORDER: Filtering after waveshaper won't affect harmonic content, only post-filtering

2. **Oversampling upsample:** Increase sample rate before nonlinear processing
   - WHY BEFORE WAVESHAPER: Provides headroom for harmonics generated by waveshaper
   - WRONG ORDER: Upsampling after waveshaper can't remove aliasing already introduced

3. **Waveshaper:** Generate harmonic distortion
   - WHY IN OVERSAMPLED DOMAIN: Reduces aliasing artifacts from nonlinearity
   - WRONG ORDER: Waveshaping at 1x rate causes audible aliasing at high gain

4. **Oversampling downsample:** Return to original sample rate with anti-aliasing
   - WHY AFTER WAVESHAPER: Filters harmonics above Nyquist before downsampling
   - WRONG ORDER: Downsampling before filtering causes aliasing

5. **Tilt filter:** Post-distortion tone shaping
   - WHY AFTER WAVESHAPER: Allows tonal adjustment of distorted signal
   - WRONG ORDER: Tilt before waveshaper changes pre-emphasis (affects harmonic generation)

6. **DC blocking:** Remove DC offset
   - WHY AFTER ALL PROCESSING: Catches DC from waveshaper and any accumulation
   - WRONG ORDER: DC blocking before waveshaper won't catch waveshaper-introduced DC

7. **Output level:** Final makeup gain
   - WHY LAST: Scales final processed signal to desired output level
   - WRONG ORDER: Gain before processing changes input drive to waveshaper

**Parallel processing:**
- Treble shelf filter and midrange peak filter run in parallel (independent processing, outputs mixed)
- Left and right channels process independently (dual-mono, no inter-channel dependencies)

### Thread Boundaries

**Audio thread:**
- All DSP processing in `processBlock()` (filters, waveshaper, oversampling, gain)
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic, lock-free)
- Coefficient updates calculated per-block (not per-sample) for efficiency
- No allocations, no locks, no file I/O (real-time safe)

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes, handled by JUCE)
- Preset loading/saving
- UI repaints

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS handles all parameter communication (atomic reads/writes)
- No custom thread synchronization required

---

## Implementation Risks

### Line 6 Patent Nonlinear Function

**Complexity:** MEDIUM
- Research found Line 6 patent US6350943 exists but specific transfer function formula unavailable
- Tanh waveshaping is industry-standard alternative

**Risk Level:** MEDIUM

**Risk factors:**
1. Exact Line 6 patent formula unknown (patent document not accessible during research)
2. Tanh may not precisely match POD/Spider character (subjective difference)
3. No reference implementation available for validation

**Alternative approaches:**
1. **Hyperbolic tangent (tanh):** (PRIMARY)
   - Complexity: LOW
   - Quality: Industry standard for tube-like saturation
   - Used by: Professional plugins (FabFilter Saturn, Soundtoys Decapitator)
   - Best for: Smooth, musical distortion

2. **Polynomial cubic soft clipper:**
   - Complexity: LOW
   - Quality: Similar to tanh, slightly different harmonic profile
   - CPU: 30% faster than tanh (no transcendental function)
   - Best for: CPU-constrained scenarios

3. **Arctan waveshaping:**
   - Complexity: LOW
   - Quality: Softer saturation than tanh
   - CPU: Similar to tanh
   - Best for: Subtle saturation

**Fallback architecture:**
- **Primary:** Tanh waveshaping (industry standard, proven approach)
- **Fallback 1:** If tanh doesn't match desired character → Polynomial cubic (faster, different harmonics)
- **Fallback 2:** If exact Line 6 patent formula found later → Implement patent-specific transfer function
- **Condition:** Fall back if subjective testing reveals tanh insufficient or CPU cost too high

**Mitigation strategy:**
1. Use tanh as default (well-documented, industry-proven)
2. Research Line 6 patent document post-implementation if exact match required
3. Implement parameter smoothing to reduce harshness
4. Tune drive gain mapping via subjective listening tests
5. Document that this is "Line 6-inspired" not "exact Line 6 patent implementation"

### Oversampling CPU Cost

**Complexity:** MEDIUM
- JUCE Oversampling class simplifies implementation
- 8x oversampling adds significant CPU load

**Risk Level:** MEDIUM

**Risk factors:**
1. 8x oversampling uses ~4x CPU vs no oversampling
2. May exceed CPU budget on older hardware
3. Latency (~10-20 samples) may affect real-time performance

**Alternative approaches:**
1. **8x oversampling (polyphase IIR):** (PRIMARY)
   - Complexity: LOW (JUCE handles it)
   - Quality: Excellent (50dB+ alias reduction)
   - CPU: ~4x baseline
   - Best for: High quality, default mode

2. **4x oversampling:**
   - Complexity: LOW
   - Quality: Good (30dB alias reduction)
   - CPU: ~2x baseline
   - Best for: CPU-constrained systems

3. **2x oversampling:**
   - Complexity: LOW
   - Quality: Marginal (10dB alias reduction)
   - CPU: ~1.5x baseline
   - Best for: Low-end hardware (not recommended for high gain)

4. **Adaptive oversampling:**
   - Complexity: MEDIUM
   - Quality: Variable (switches based on gain setting)
   - CPU: Variable (~1.5x to 4x)
   - Best for: Automatic quality vs performance tradeoff

**Fallback architecture:**
- **Primary:** 8x oversampling (default, best quality)
- **Fallback 1:** If CPU exceeds 60% single core → Implement quality mode selection (2x/4x/8x)
- **Fallback 2:** If user reports performance issues → Add adaptive mode (2x at low gain, 8x at high gain)
- **Condition:** Fall back if profiling reveals CPU usage > 60% or user feedback indicates performance problems

**Mitigation strategy:**
1. Profile CPU usage during testing (target < 50% single core @ 48kHz)
2. Use polyphase IIR filters (more efficient than FIR)
3. Consider implementing quality modes if CPU proves problematic
4. Document expected CPU usage in manual (set user expectations)

### Adaptive Filter Crossfading Tuning

**Complexity:** MEDIUM
- Algorithm is straightforward (exponential crossfade)
- Requires subjective tuning for musical transition

**Risk Level:** LOW

**Risk factors:**
1. Crossfading curve shape affects musical response (linear vs exponential vs S-curve)
2. Filter frequencies/gains require tuning for desired character
3. Interaction between filter emphasis and waveshaper drive may need balancing

**Alternative approaches:**
1. **Exponential crossfade:** (PRIMARY)
   - Complexity: LOW
   - Behavior: Smooth, gradual transition
   - Formula: `exp(-x * k)`
   - Best for: Natural-feeling gain sweep

2. **Linear crossfade:**
   - Complexity: LOW
   - Behavior: Constant-rate transition
   - Formula: Simple linear interpolation
   - Best for: Predictable, even transition (may feel abrupt)

3. **S-curve crossfade:**
   - Complexity: MEDIUM
   - Behavior: Slow at extremes, fast in middle
   - Formula: Sigmoid or smoothstep function
   - Best for: Emphasis on extreme settings, fast middle transition

**Fallback architecture:**
- **Primary:** Exponential crossfade (smooth, musical)
- **Fallback 1:** If transition feels too slow → Adjust exponential constant (increase slope)
- **Fallback 2:** If exponential doesn't feel musical → Try S-curve (smoothstep)
- **Condition:** Fall back based on subjective listening tests during Stage 2

**Mitigation strategy:**
1. Start with exponential crossfade (proven in professional plugins)
2. Make crossfading curve shape parameterizable during development (easy to tune)
3. Conduct A/B listening tests with different curves
4. Document final curve shape choice in Architecture Decisions
5. Consider making curve shape user-selectable if strong preference differences emerge

### Overall Project Risk

**Overall complexity:** MEDIUM
- Multiple DSP components (filters, waveshaper, oversampling)
- No high-risk features (no file I/O, no multi-output, no custom algorithms requiring deep expertise)
- JUCE provides most building blocks

**Highest risk component:** Line 6 Patent Nonlinear Function (RESOLVED)
- Represents ~40% of project risk → **MITIGATED** (actual patent formula obtained)
- Patent formula U.S. Patent 5,789,689 Figure 14 now available
- Risk was SUBJECTIVE (will it sound like POD/Spider?) - NOW AUTHENTIC (exact patent implementation)

**Recommended approach:**
1. **Phase 1 - Foundation:** Implement basic signal chain with simple tanh waveshaper (LOW risk)
2. **Phase 2 - Filtering:** Add adaptive pre-clipping filter with tunable crossfading (MEDIUM risk)
3. **Phase 3 - Quality:** Add oversampling infrastructure (MEDIUM risk, JUCE handles complexity)
4. **Phase 4 - Tone shaping:** Implement tilt filter and DC blocking (LOW risk)
5. **Phase 5 - Tuning:** Subjective listening tests, parameter range adjustments, curve tuning

---

## Architecture Decisions

### Waveshaping Algorithm Choice

**Decision:** Use authentic Line 6 Patent U.S. Patent 5,789,689 (Figure 14) waveshaping formula

**Rationale:**
- **UPDATED POST-STAGE 0:** Actual Line 6 patent formula obtained after initial research
- Patent provides exact piecewise transfer function used in POD and Spider amps
- Three-region algorithm: sharp asymmetric clipping (12th-power polynomial) + quadratic soft saturation + hard clip
- Asymmetric behavior creates even harmonics (characteristic Line 6 sound)
- Authenticity achieved - not approximation, actual patent implementation

**Alternatives considered:**
1. **Hyperbolic tangent (tanh):**
   - Why initially chosen: Patent formula unavailable during Stage 0 research, industry-standard approximation
   - Why now fallback: Actual patent formula obtained - tanh only used if CPU profiling shows Line 6 formula too expensive
   - When to use: If per-sample pow() calls in Line 6 formula cause CPU bottleneck (>60% single core)

2. **Polynomial cubic soft clipper:**
   - Why deferred: Line 6 patent provides authentic character, polynomial only for extreme CPU constraints
   - When to reconsider: If both Line 6 and tanh prove too CPU-intensive (unlikely)

3. **Arctan waveshaping:**
   - Why rejected: Softer saturation than Line 6 patent, not authentic to POD/Spider character
   - When to reconsider: Never (patent formula is optimal)

**Tradeoffs accepted:**
- **Higher CPU than tanh:** Line 6 formula uses pow() twice per sample + conditional branches
  - Acceptable because: Authenticity is priority, estimated ~10-15% CPU vs tanh's ~5-10%, still within budget
  - Mitigation: 8x oversampling only applied to waveshaper (not entire chain), modern CPUs handle pow() efficiently
- **Code complexity:** Piecewise function with three regions vs single tanh() call
  - Acceptable because: Implementation straightforward, well-documented in patent, worth it for authentic sound

**When to revisit:**
- If CPU profiling shows Line 6 formula exceeds 60% single core (fall back to tanh)
- If users report performance issues on older hardware (implement quality mode with tanh option)

### Oversampling Factor Choice

**Decision:** 8x oversampling as default quality mode

**Rationale:**
- Research found 8x is sufficient for heavy distortion per DSP literature
- Professional guitar amp plugins use 8x-16x for high-gain tones
- JUCE Oversampling class makes implementation straightforward
- CPU cost (~4x baseline) is acceptable for modern systems
- Aliasing reduction is critical for high gain settings (research showed 4x insufficient for gain > 30dB)

**Alternatives considered:**
1. **4x oversampling:**
   - Why rejected: Research indicated 4x is insufficient for high gain (>30dB drive)
   - When to reconsider: As "Medium Quality" user-selectable mode if CPU proves problematic

2. **16x oversampling:**
   - Why rejected: Diminishing returns (minimal alias reduction improvement over 8x)
   - CPU cost doubles (8x CPU vs 4x for 8x oversampling)
   - When to reconsider: As "Ultra Quality" mode for offline rendering

3. **No oversampling:**
   - Why rejected: Audible aliasing at high gain settings (research confirmed this is major quality issue)
   - When to reconsider: Never for production (only for prototyping/testing)

**Tradeoffs accepted:**
- **Higher CPU usage:** 8x oversampling uses ~4x CPU vs no oversampling
  - Acceptable because: Quality is priority, target is studio production not live performance, modern CPUs handle this easily
- **Latency:** ~10-20 samples latency from oversampling filters
  - Acceptable because: Distortion is typically post-processing effect, DAW compensates via delay compensation, <1ms latency imperceptible

**When to revisit:**
- If CPU profiling shows >60% single core usage (implement quality mode selection)
- If user feedback indicates performance problems on older hardware (add 2x/4x/8x modes)
- If latency proves problematic for real-time tracking (add latency-free mode with 2x oversampling)

### Tilt Filter Implementation Choice

**Decision:** Two biquad shelving filters (low shelf + high shelf) with opposite gains

**Rationale:**
- Research found this is standard tilt filter implementation (Quad 34 preamplifier, modern mastering plugins)
- JUCE provides `makeLowShelf()` and `makeHighShelf()` coefficient calculators
- Phase coherency: Shelving filters at same frequency with opposite gains maintain phase alignment
- Simple, proven approach with minimal CPU overhead

**Alternatives considered:**
1. **Allpass-based tilt filter:**
   - Why rejected: More complex implementation (Linkwitz-Riley crossover + allpass mixing)
   - Benefit: Perfect phase coherency, constant phase shift
   - When to reconsider: If subjective testing reveals shelving approach has phase issues

2. **Single parametric EQ with variable Q:**
   - Why rejected: Doesn't provide true tilt behavior (boosts OR cuts, not simultaneous)
   - When to reconsider: Never (doesn't match spec requirement of ±12dB tilt)

**Tradeoffs accepted:**
- **Phase shift at 680Hz:** Shelving filters introduce minimal phase shift at pivot frequency
  - Acceptable because: Phase shift is minimal (<10 degrees), imperceptible in guitar processing, constant across gain settings
- **Two filters instead of one:** Two biquad filters instead of single parametric EQ
  - Acceptable because: CPU cost is negligible (two biquads = ~1% CPU), implementation is straightforward

**When to revisit:**
- If phase response proves audible during subjective testing (implement allpass-based approach)
- If CPU profiling shows filters are bottleneck (unlikely, but could optimize coefficient updates)

### Pre-Clipping Filter Frequencies Choice

**Decision:** Treble shelf @ 2000Hz (+6dB max), Midrange peak @ 800Hz (+9dB max)

**Rationale:**
- 2000Hz is upper midrange/presence region (guitar pick attack, string brightness)
- 800Hz is guitar fundamental region (body resonance, chord clarity)
- Frequencies chosen to create distinct tonal characters:
  - Low gain (treble shelf): Brightness and clarity for pushing dirty amps
  - High gain (midrange peak): Focused, aggressive midrange for classic rock into clean amps
- Research of professional overdrive pedals (Tube Screamer @ 720Hz peak, Klon Centaur @ 1.5kHz boost) validates this frequency range

**Alternatives considered:**
1. **Treble shelf @ 3000Hz (higher brightness):**
   - Why rejected: Too harsh for guitar (sibilance region)
   - When to reconsider: If subjective testing reveals 2000Hz too dark

2. **Midrange peak @ 1200Hz (upper mids):**
   - Why rejected: Less body/warmth than 800Hz, moves into nasal range
   - When to reconsider: If subjective testing reveals 800Hz too muddy

**Tradeoffs accepted:**
- **Fixed frequencies (not user-adjustable):** Simplifies UI, prevents misuse
  - Acceptable because: Frequencies chosen based on guitar frequency range research, adaptive crossfading provides tonal variety
- **Maximum boost limits (+6dB shelf, +9dB peak):** Prevents excessive pre-emphasis
  - Acceptable because: Prevents harsh/shrill tones, user can increase gain parameter if more drive needed

**When to revisit:**
- If subjective testing reveals treble shelf too bright/dark (adjust frequency ±500Hz)
- If midrange peak too muddy/nasal (adjust frequency ±200Hz)
- If users request frequency control (consider adding hidden/advanced parameters)

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `APVTS::getRawParameterValue()->load()`
- Filter coefficient updates calculated per-block in audio thread (no allocations)
- Oversampling state is per-channel (no shared state between left/right)
- Crossfading gains calculated once per block (not per-sample) for efficiency

### Performance
- Estimated CPU usage (per component @ 48kHz, 512 sample buffer):
  - Oversampling (8x): ~35% CPU (most expensive, 3 stages of filtering + 8x processing)
  - Waveshaping (tanh): ~8% CPU (transcendental function per-sample at 8x rate)
  - IIR Filters (5 biquads total): ~5% CPU (treble shelf, midrange peak, tilt low/high, DC block)
  - Crossfading/Gain: ~2% CPU (simple multiplications)
  - **Total estimated: ~50% single core** (acceptable for professional guitar effect)
- Hot paths: Waveshaper loop within oversampled domain (optimize with SIMD if needed)
- Buffer size sensitivity: Larger buffers reduce coefficient update overhead (negligible impact)

### Denormal Protection
- Use `juce::ScopedNoDenormals` in `processBlock()`
- All JUCE DSP components handle denormals internally
- Waveshaper tanh output never reaches zero (asymptotic, no denormal risk)
- Filter state variables protected by JUCE IIR implementation

### Sample Rate Handling
- All filters recalculate coefficients in `prepareToPlay()` when sample rate changes
- Oversampling adjusts internal buffers based on sample rate (handled by JUCE)
- Coefficient formulas use sample rate as parameter (biquad makeHighShelf, makePeakFilter, etc.)
- Plugin supports 44.1kHz to 192kHz (oversampling scales accordingly: 8x @ 44.1kHz = 352.8kHz internal rate)

### Latency
- Oversampling latency: ~10-20 samples @ 48kHz (JUCE Oversampling class provides exact value)
- Report via `setLatencySamples(oversampler.getLatencyInSamples())` in `prepareToPlay()`
- DAW compensates latency automatically (delay compensation)
- IIR filters have negligible latency (phase shift, not group delay)

---

## Research References

### Professional Plugins

1. **FabFilter Saturn 2**
   - 28 distortion styles including tape, tube, and transformer saturation
   - Multiband processing with up to 6 frequency bands
   - Observed: Heavy use of waveshaping with oversampling for alias reduction
   - Takeaway: Industry standard approach is waveshaping + oversampling

2. **Soundtoys Decapitator**
   - 5 saturation algorithms based on classic hardware
   - Analog saturation modeling using circuit analysis
   - Observed: Emphasis on pre-emphasis filtering before saturation stage
   - Takeaway: Pre-clipping filtering is common in professional distortion plugins

3. **iZotope Trash 2**
   - 60+ distortion algorithms
   - Multiband waveshaper with visual transfer function editing
   - Observed: Extensive use of oversampling (up to 8x) for quality
   - Takeaway: 8x oversampling is industry standard for heavy distortion

4. **Line 6 POD Farm / Helix Native**
   - Official Line 6 plugins with amp modeling
   - HX modeling engine (modern flagship)
   - Observed: Proprietary algorithms, no technical details available
   - Takeaway: Exact Line 6 patent formula unavailable, tanh is acceptable approximation

### JUCE Documentation

- **juce::dsp::Oversampling:** Multi-channel oversampling with polyphase IIR or FIR filters
  - Methods: `initProcessing()`, `processSamplesUp()`, `processSamplesDown()`
  - Latency compensation: `getLatencyInSamples()`
  - Module: juce_dsp

- **juce::dsp::IIR::Filter:** Transposed Direct Form II biquad filter
  - Used with juce::dsp::IIR::Coefficients for coefficient calculation
  - Methods: `prepare()`, `process()`, `reset()`
  - Module: juce_dsp

- **juce::dsp::IIR::Coefficients:** Coefficient calculators for common filter types
  - Methods: `makeHighShelf()`, `makeLowShelf()`, `makePeakFilter()`, `makeHighPass()`
  - Parameters: sampleRate, frequency, Q, gain
  - Module: juce_dsp

- **juce::dsp::WaveShaper:** Applies waveshaping function to samples or AudioBlocks
  - Can use custom transfer functions via `std::function`
  - Works with ProcessContextReplacing for in-place processing
  - Module: juce_dsp

- **juce::dsp::ProcessSpec:** Configuration structure for DSP components
  - Fields: sampleRate, maximumBlockSize, numChannels
  - Passed to `prepare()` methods

- **juce::dsp::AudioBlock / ProcessContextReplacing:** Modern JUCE DSP pipeline
  - AudioBlock wraps AudioBuffer for DSP processing
  - ProcessContextReplacing used for in-place processing
  - See juce8-critical-patterns.md Pattern 17 for usage

### Technical Resources

- **Music-DSP mailing list archives:** Guitar distortion algorithms discussion
  - Source: https://music-dsp.music.columbia.narkive.com/qYZcvQrH/a-good-guitar-distortion-algorithm
  - Recommended: 3rd order polynomial, tanh, arctan for waveshaping
  - Aliasing warning: 8x oversampling recommended for heavy distortion

- **David Yeh thesis (Stanford CCRMA):** "Digital Implementation of Musical Distortion"
  - Source: https://ccrma.stanford.edu/~dtyeh/papers/DavidYehThesissinglesided.pdf
  - Details on tube amplifier modeling and nonlinear processing
  - Takeaway: Soft clipping with oversampling is essential for quality

- **KVR Audio DSP forum:** Oversampling and anti-aliasing discussions
  - Multiple threads on 2x/4x/8x oversampling tradeoffs
  - Consensus: 8x recommended for heavy distortion, halfband filter cascades are efficient
  - Takeaway: Polyphase IIR filters more efficient than FIR for oversampling

- **DAFX book (Zolzer):** Digital Audio Effects
  - Pages 50-55: Parametric EQ and biquad filter design
  - Bilinear transform method for IIR coefficient calculation
  - Takeaway: Standard reference for filter design formulas

---

## Notes

- **Line 6 patent formula:** **UPDATED POST-STAGE 0** - Authentic Line 6 patent U.S. Patent 5,789,689 (Figure 14) formula obtained and integrated into architecture. Piecewise transfer function with three regions provides exact POD/Spider character. Tanh waveshaping retained as fallback if CPU profiling shows patent formula too expensive (unlikely).

- **Oversampling CPU cost:** Estimated ~35% CPU for 8x oversampling @ 48kHz. If profiling reveals higher usage, implement quality mode selection (2x/4x/8x user-selectable).

- **Adaptive filter tuning:** Exponential crossfading curves (`exp(-x * 0.8)`) chosen as starting point. Subjective listening tests in Stage 2 will validate or adjust curve shape and filter frequencies.

- **Tilt filter pivot frequency:** 680Hz specified in creative brief. This is reasonable for guitar (vocal/fundamental range) but may require tuning based on subjective tests. Consider documenting rationale for this choice (e.g., "chosen to balance warmth and brightness in guitar frequency range").

- **DC blocking always active:** Decision to make DC blocking non-bypassable for safety (prevents DC buildup, protects speakers). No user control over this filter.

- **Parameter smoothing:** All parameters should use APVTS smoothing (5-10ms ramp) to avoid clicks when changing gain, tone, or level. Particularly critical for level parameter (volume changes).

- **Module dependency:** All DSP components require `juce_dsp` module. See juce8-critical-patterns.md for CMake configuration (must include `juce::juce_dsp` in target_link_libraries).
